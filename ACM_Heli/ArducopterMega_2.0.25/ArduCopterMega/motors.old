void
set_servos_4()
{
	static byte num;
	int out_min;

	// Quadcopter mix
	if (motor_armed == true && motor_auto_safe == true) {
		out_min = g.rc_3.radio_min;

		// Throttle is 0 to 1000 only
		g.rc_3.servo_out 	= constrain(g.rc_3.servo_out, 0, 1000);

		if(g.rc_3.servo_out > 0)
			out_min = g.rc_3.radio_min + 90;

		//Serial.printf("out: %d %d %d %d\t\t", g.rc_1.servo_out, g.rc_2.servo_out, g.rc_3.servo_out, g.rc_4.servo_out);

		// creates the radio_out and pwm_out values
		g.rc_1.calc_pwm();
		g.rc_2.calc_pwm();
		g.rc_3.calc_pwm();
		g.rc_4.calc_pwm();

		// limit Yaw control so we don't clip and loose altitude
		// this is only a partial solution.

		// g.rc_4.pwm_out = min(g.rc_4.pwm_out, (g.rc_3.radio_out - out_min));

		//Serial.printf("out: %d %d %d %d\n", g.rc_1.radio_out, g.rc_2.radio_out, g.rc_3.radio_out, g.rc_4.radio_out);
		//Serial.printf("yaw: %d ", g.rc_4.radio_out);

		if(g.frame_type == PLUS_FRAME){
			//Serial.println("P_FRAME");
			motor_out[CH_1]		= g.rc_3.radio_out - g.rc_1.pwm_out;
			motor_out[CH_2]		= g.rc_3.radio_out + g.rc_1.pwm_out;
			motor_out[CH_3]		= g.rc_3.radio_out + g.rc_2.pwm_out;
			motor_out[CH_4] 	= g.rc_3.radio_out - g.rc_2.pwm_out;

			motor_out[CH_1]		+=  g.rc_4.pwm_out; 	// CCW
			motor_out[CH_2]		+=  g.rc_4.pwm_out; 	// CCW
			motor_out[CH_3]		-=  g.rc_4.pwm_out; 	// CW
			motor_out[CH_4] 	-=  g.rc_4.pwm_out; 	// CW

		}else if(g.frame_type == X_FRAME){
			//Serial.println("X_FRAME");
			int roll_out 	 	= g.rc_1.pwm_out * .707;
			int pitch_out 	 	= g.rc_2.pwm_out * .707;

			// left
			motor_out[CH_3]	 	= g.rc_3.radio_out + roll_out + pitch_out;	// FRONT
			motor_out[CH_2]	 	= g.rc_3.radio_out + roll_out - pitch_out;	// BACK

			// right
			motor_out[CH_1]		= g.rc_3.radio_out - roll_out + pitch_out;  // FRONT
			motor_out[CH_4] 	= g.rc_3.radio_out - roll_out - pitch_out;	// BACK

			//Serial.printf("\tb4: %d %d %d %d ", motor_out[CH_1], motor_out[CH_2], motor_out[CH_3], motor_out[CH_4]);

			motor_out[CH_1]		+= g.rc_4.pwm_out;	// CCW
			motor_out[CH_2]		+= g.rc_4.pwm_out;	// CCW
			motor_out[CH_3]		-= g.rc_4.pwm_out;	// CW
			motor_out[CH_4] 	-= g.rc_4.pwm_out;	// CW

			//Serial.printf("\tl8r: %d %d %d %d\n", motor_out[CH_1], motor_out[CH_2], motor_out[CH_3], motor_out[CH_4]);

		}else if(g.frame_type == TRI_FRAME){

			//Serial.println("TRI_FRAME");
			// Tri-copter power distribution

			int roll_out 		= (float)g.rc_1.pwm_out * .866;
			int pitch_out 		= g.rc_2.pwm_out / 2;

			//left front
			motor_out[CH_2]		= g.rc_3.radio_out + roll_out + pitch_out;

			//right front
			motor_out[CH_1]		= g.rc_3.radio_out - roll_out + pitch_out;

			// rear
			motor_out[CH_4] 	= g.rc_3.radio_out - g.rc_2.pwm_out;

			// this is a compensation for the angle of the yaw motor. Its linear, but should work ok.
			//motor_out[CH_4]		+= (float)(abs(g.rc_4.control_in)) * .013;


		}else if (g.frame_type == HEXAX_FRAME) {
			//Serial.println("6_FRAME");

			int roll_out 		= (float)g.rc_1.pwm_out * .866;
			int pitch_out 		= g.rc_2.pwm_out / 2;

			//left side
			motor_out[CH_2]		= g.rc_3.radio_out + g.rc_1.pwm_out;		// CCW
			motor_out[CH_3]		= g.rc_3.radio_out + roll_out + pitch_out;	// CW
			motor_out[CH_8]     = g.rc_3.radio_out + roll_out - pitch_out;	// CW

			//right side
			motor_out[CH_1]		= g.rc_3.radio_out - g.rc_1.pwm_out;		// CW
            motor_out[CH_7] 	= g.rc_3.radio_out - roll_out + pitch_out;	// CCW
			motor_out[CH_4] 	= g.rc_3.radio_out - roll_out - pitch_out;	// CCW

			motor_out[CH_2]		+= g.rc_4.pwm_out;	// CCW
			motor_out[CH_7]		+= g.rc_4.pwm_out;	// CCW
			motor_out[CH_4] 	+= g.rc_4.pwm_out;	// CCW

			motor_out[CH_3]		-= g.rc_4.pwm_out;	// CW
			motor_out[CH_1]		-= g.rc_4.pwm_out;	// CW
			motor_out[CH_8]		-= g.rc_4.pwm_out;  // CW

		}else if (g.frame_type == HEXAP_FRAME) {
			//Serial.println("HEXAP_FRAME");
			int roll_out 		= g.rc_1.pwm_out;
			int pitch_out 		= (float)g.rc_2.pwm_out * .5;

			//Back side
			motor_out[CH_8]		= g.rc_3.radio_out - g.rc_2.pwm_out;		// CCW	BACK
			motor_out[CH_1]		= g.rc_3.radio_out + roll_out - pitch_out;	// CW, 	BACK LEFT
			motor_out[CH_3]		= g.rc_3.radio_out - roll_out - pitch_out;	// CW	BACK RIGHT

			//Front side
			motor_out[CH_7]		= g.rc_3.radio_out + g.rc_2.pwm_out;		// CW	 FRONT
			motor_out[CH_2] 	= g.rc_3.radio_out + roll_out + pitch_out;	// CCW	 FRONT LEFT
			motor_out[CH_4] 	= g.rc_3.radio_out - roll_out + pitch_out;	// CCW	 FRONT RIGHT

			motor_out[CH_8]		+= g.rc_4.pwm_out;	// CCW
			motor_out[CH_2]		+= g.rc_4.pwm_out;	// CCW
			motor_out[CH_4] 	+= g.rc_4.pwm_out;	// CCW

			motor_out[CH_1]		-= g.rc_4.pwm_out;	// CW
			motor_out[CH_7]		-= g.rc_4.pwm_out;	// CW
			motor_out[CH_3]		-= g.rc_4.pwm_out;  // CW

		}else if (g.frame_type == Y6_FRAME) {
			//Serial.println("Y6_FRAME");

			int roll_out 		= (float)g.rc_1.pwm_out * .866;
			int pitch_out 		=  g.rc_2.pwm_out / 2;

			//left
			motor_out[CH_2]		= ((g.rc_3.radio_out * Y6_scaling) + roll_out + pitch_out);  // CCW TOP
			motor_out[CH_3]		=  g.rc_3.radio_out + roll_out + pitch_out;			// CW

			//right
			motor_out[CH_7]		= ((g.rc_3.radio_out * Y6_scaling) - roll_out + pitch_out);	// CCW TOP
			motor_out[CH_1]		=  g.rc_3.radio_out - roll_out + pitch_out;			// CW

			//back
			motor_out[CH_8]     = ((g.rc_3.radio_out * Y6_scaling) - g.rc_2.pwm_out);	// CCW TOP
			motor_out[CH_4] 	=  g.rc_3.radio_out - g.rc_2.pwm_out;			// CW

			//yaw
			motor_out[CH_2]		+= g.rc_4.pwm_out;	// CCW
			motor_out[CH_7]		+= g.rc_4.pwm_out;	// CCW
			motor_out[CH_8] 	+= g.rc_4.pwm_out;	// CCW

			motor_out[CH_3]		-= g.rc_4.pwm_out;	// CW
			motor_out[CH_1]		-= g.rc_4.pwm_out;	// CW
			motor_out[CH_4]		-= g.rc_4.pwm_out;  // CW

    	}else{

			//Serial.print("frame error");

		}


		// limit output so motors don't stop
		motor_out[CH_1]		= constrain(motor_out[CH_1], 	out_min, g.rc_3.radio_max.get());
		motor_out[CH_2]		= constrain(motor_out[CH_2], 	out_min, g.rc_3.radio_max.get());
		motor_out[CH_3]		= constrain(motor_out[CH_3], 	out_min, g.rc_3.radio_max.get());
		motor_out[CH_4] 	= constrain(motor_out[CH_4], 	out_min, g.rc_3.radio_max.get());


		if ((g.frame_type == HEXAX_FRAME) || (g.frame_type == HEXAP_FRAME) || (g.frame_type == Y6_FRAME)) {
			motor_out[CH_7]		= constrain(motor_out[CH_7], 	out_min, g.rc_3.radio_max.get());
			motor_out[CH_8]		= constrain(motor_out[CH_8], 	out_min, g.rc_3.radio_max.get());
		}

		// Send commands to motors
		if(g.rc_3.servo_out > 0){

			APM_RC.OutputCh(CH_1, motor_out[CH_1]);
			APM_RC.OutputCh(CH_2, motor_out[CH_2]);
			APM_RC.OutputCh(CH_3, motor_out[CH_3]);
			APM_RC.OutputCh(CH_4, motor_out[CH_4]);
			// InstantPWM
			APM_RC.Force_Out0_Out1();
			APM_RC.Force_Out2_Out3();

			if ((g.frame_type == HEXAX_FRAME) || (g.frame_type == Y6_FRAME)) {
				APM_RC.OutputCh(CH_7, motor_out[CH_7]);
				APM_RC.OutputCh(CH_8, motor_out[CH_8]);
				APM_RC.Force_Out6_Out7();
			}

		}else{

			APM_RC.OutputCh(CH_1, g.rc_3.radio_min);
			APM_RC.OutputCh(CH_2, g.rc_3.radio_min);
			APM_RC.OutputCh(CH_3, g.rc_3.radio_min);
			APM_RC.OutputCh(CH_4, g.rc_3.radio_min);
			// InstantPWM
			APM_RC.Force_Out0_Out1();
			APM_RC.Force_Out2_Out3();

			if ((g.frame_type == HEXAX_FRAME) || (g.frame_type == Y6_FRAME)) {
				APM_RC.OutputCh(CH_7, g.rc_3.radio_min);
				APM_RC.OutputCh(CH_8, g.rc_3.radio_min);
				APM_RC.Force_Out6_Out7();
			}
		}

	}else{
		// our motor is unarmed, we're on the ground

		if(g.rc_3.control_in > 0){
			// we have pushed up the throttle
			// remove safety
			motor_auto_safe = true;
		}

		// fill the motor_out[] array for HIL use
		for (unsigned char i = 0; i < 8; i++) {
			motor_out[i] = g.rc_3.radio_min;
		}

		// Send commands to motors
		APM_RC.OutputCh(CH_1, motor_out[CH_1]);
		APM_RC.OutputCh(CH_2, motor_out[CH_2]);
		APM_RC.OutputCh(CH_3, motor_out[CH_3]);
		APM_RC.OutputCh(CH_4, motor_out[CH_4]);


		if ((g.frame_type == HEXAX_FRAME) || (g.frame_type == Y6_FRAME)){
			APM_RC.OutputCh(CH_7, motor_out[CH_7]);
			APM_RC.OutputCh(CH_8, motor_out[CH_8]);
		}

		// reset I terms of PID controls
		//reset_I();

		// Initialize yaw command to actual yaw when throttle is down...
		g.rc_4.control_in = ToDeg(dcm.yaw);
	}
 }

